"""
Module for BaseStatement and builtin Deirokay statements.
"""

from typing import Optional

import pandas as pd
from jinja2 import BaseLoader
from jinja2.nativetypes import NativeEnvironment

from .fs import FileSystem
from .history_template import get_series

import re


class BaseStatement:
    """Base abstract statement class for all Deirokay statements.

    Attributes
    ----------
    name : str
        Statement name when referred in Validation Documents (only
        valid for non-custom statements).
    expected_parameters : List[str]
        Parameters expected for this statement.
    table_only : bool
        Whether or not this statement in applicable only to the entire
        table, instead of scoped columns.
    jinjaenv : NativeEnvironment
        Jinja Environment to use when rendering templates. Only for
        advanced users.
    """

    name = 'base_statement'
    expected_parameters = ['type', 'severity', 'location']
    table_only = False
    jinjaenv = NativeEnvironment(loader=BaseLoader())

    def __init__(self, options: dict, read_from: Optional[FileSystem] = None):
        """Load statement options and render its parameters.

        Parameters
        ----------
        options : dict
            Statement parameters provided by user.
        read_from : Optional[FileSystem], optional
            Where read past validation logs from
            (necessary for templated moving statistics).
            By default None.
        """
        self._validate_options(options)
        self.options = options
        self._read_from = read_from
        self._parse_options()

    def _validate_options(self, options: dict):
        """Make sure all providded statement parameters are expected
        by statement classes"""
        cls = type(self)
        unexpected_parameters = [
            option for option in options
            if option not in (cls.expected_parameters +
                              BaseStatement.expected_parameters)
        ]
        if unexpected_parameters:
            raise ValueError(
                f'Invalid parameters passed to {cls.__name__} statement: '
                f'{unexpected_parameters}\n'
                f'The valid parameters are: {cls.expected_parameters}'
            )

    def _parse_options(self):
        """Render Jinja templates in statement parameters."""
        for key, value in self.options.items():
            if isinstance(value, str):
                rendered = (
                    BaseStatement.jinjaenv.from_string(value)
                    .render(
                        series=lambda x, y: get_series(x, y, self._read_from)
                    )
                )
                self.options[key] = rendered

    def __call__(self, df: pd.DataFrame):
        """Run statement instance."""
        internal_report = self.report(df)
        result = self.result(internal_report)

        final_report = {
            'detail': internal_report,
            'result': result
        }
        return final_report

    def report(self, df: pd.DataFrame) -> dict:
        """Receive a DataFrame containing only columns on the scope of
        validation and returns a report of related metrics that can
        be used later to declare this Statement as fulfilled or
        failed.

        Parameters
        ----------
        df : pd.DataFrame
            The scoped DataFrame columns to be analysed in this report
            by this statement.

        Returns
        -------
        dict
            A dictionary of useful statistics about the target columns.
        """
        return {}

    def result(self, report: dict) -> bool:
        """Receive the report previously generated and declare this
        statement as either fulfilled (True) or failed (False).

        Parameters
        ----------
        report : dict
            Report generated by `report` method. Should ideally
            contain all statistics necessary to evaluate the statement
            validity.

        Returns
        -------
        bool
            Whether or not this statement passed.
        """
        return True

    @staticmethod
    def profile(df: pd.DataFrame) -> dict:
        """Given a template data table, generate a statement dict
        from it.

        Parameters
        ----------
        df : pd.DataFrame
            The DataFrame to be used as template.

        Returns
        -------
        dict
            Statement dict.
        """
        raise NotImplementedError


# docstr-coverage:inherited
class Unique(BaseStatement):
    name = 'unique'
    expected_parameters = ['at_least_%']

    def __init__(self, *args, **kwargs):
        """Check if the rows of a scoped DataFrame are unique."""
        super().__init__(*args, **kwargs)

        self.at_least_perc = self.options.get('at_least_%', 100.0)

    # docstr-coverage:inherited
    def report(self, df):
        unique = ~df.duplicated(keep=False)

        report = {
            'unique_rows': int(unique.sum()),
            'unique_rows_%': float(100.0*unique.sum()/len(unique)),
        }
        return report

    # docstr-coverage:inherited
    def result(self, report):
        return report.get('unique_rows_%') >= self.at_least_perc

    # docstr-coverage:inherited
    @staticmethod
    def profile(df):
        unique = ~df.duplicated(keep=False)

        statement = {
            'type': 'unique',
            'at_least_%': float(100.0*unique.sum()/len(unique)),
        }
        return statement


# docstr-coverage:inherited
class NotNull(BaseStatement):
    name = 'not_null'
    expected_parameters = ['at_least_%', 'at_most_%', 'multicolumn_logic']

    def __init__(self, *args, **kwargs):
        """Check if the rows of a scoped DataFrame are not null."""
        super().__init__(*args, **kwargs)

        self.at_least_perc = self.options.get('at_least_%', 100.0)
        self.at_most_perc = self.options.get('at_most_%', 100.0)
        self.multicolumn_logic = self.options.get('multicolumn_logic', 'any')

        assert self.multicolumn_logic in ('any', 'all')

    # docstr-coverage:inherited
    def report(self, df):
        if self.multicolumn_logic == 'all':
            #  REMINDER: ~all == any
            not_nulls = ~df.isnull().any(axis=1)
        else:
            not_nulls = ~df.isnull().all(axis=1)

        report = {
            'null_rows': int((~not_nulls).sum()),
            'null_rows_%': float(100.0*(~not_nulls).sum()/len(not_nulls)),
            'not_null_rows': int(not_nulls.sum()),
            'not_null_rows_%': float(100.0*not_nulls.sum()/len(not_nulls)),
        }
        return report

    # docstr-coverage:inherited
    def result(self, report):
        if not report.get('not_null_rows_%') >= self.at_least_perc:
            return False
        if not report.get('not_null_rows_%') <= self.at_most_perc:
            return False
        return True

    # docstr-coverage:inherited
    @staticmethod
    def profile(df):
        not_nulls = ~df.isnull().all(axis=1)

        statement = {
            'type': 'not_null',
            'multicolumn_logic': 'any',
            'at_least_%': float(100.0*not_nulls.sum()/len(not_nulls)),
            'at_most_%': float(100.0*not_nulls.sum()/len(not_nulls))
        }
        return statement


# docstr-coverage:inherited
class RowCount(BaseStatement):
    name = 'row_count'
    expected_parameters = ['min', 'max']
    table_only = True

    def __init__(self, *args, **kwargs):
        """Check if the number of rows in a DataFrame is within a
        range."""
        super().__init__(*args, **kwargs)

        self.min = self.options.get('min', None)
        self.max = self.options.get('max', None)

    # docstr-coverage:inherited
    def report(self, df):
        row_count = len(df)

        report = {
            'rows': row_count,
        }
        return report

    # docstr-coverage:inherited
    def result(self, report):
        row_count = report['rows']

        if self.min is not None:
            if not row_count >= self.min:
                return False
        if self.max is not None:
            if not row_count <= self.max:
                return False
        return True

    # docstr-coverage:inherited
    @staticmethod
    def profile(df):
        row_count = len(df)

        statement = {
            'type': 'row_count',
            'min': row_count,
            'max': row_count,
        }
        return statement


class Regex(BaseStatement):
    """Check if the rows of a scoped DataFrame obey to a regex pattern."""

    name = 'regex'
    expected_parameters = ['pattern', 'at_least_%']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.pattern = self.options.get('pattern', '.')
        self.at_least_perc = self.options.get('at_least_%', 100.0)

    def report(self, df):

        report = {}

        for column in df.columns:
            matches = df[column].apply(lambda x: bool(
                                       re.fullmatch(self.pattern, str(x))))
            report[column] = {
                'matching_rows': int(matches.sum()),
                'matching_rows_%': float(100*matches.sum()/len(matches)),
                'not_matching_rows': int((~matches).sum()),
                'not_matching_rows_%': float(100.0*(~matches).sum(
                                                              )/len(matches)),
            }

        # print('report:\n', pd.DataFrame(report).to_markdown())

        return report

    def result(self, report):
        for col_report in report:
            if not report[col_report].get('matching_rows_%'
                                          ) >= self.at_least_perc:
                return False
        return True
